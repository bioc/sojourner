#### plotIndividualMSD.R
#### Wu Lab, Johns Hopkins University
#### Author: Xiaona Tang
#### Date: Aug 15, 2018

## plotIndividualMSD-methods
##
###############################################################################
##' @name plotIndividualMSD
##' @aliases plotIndividualMSD
##' @title plotIndividualMSD
##' @rdname plotIndividualMSD-methods
##' @docType methods
##' @description Plot the correlation between diffusion coefficient and Rsquare of the MSD fit in a trackll. With an option to plot MSD and linear regression of individual tracks one by one, with grid layout.
##'              Tracks can be sorted by their lengths, diffusion coefficient or R square of the MSD linear regresson.
##' @usage
##'
##' plotIndividualMSD(trackll=trackll,dt=6,lag=c(2:5),resolution=0.107,t.interval=0.01,sort="Rsquare",plot.fit=TRUE)
##'
##' @param trackll trajectory list generated by createTrackll() and processing. 
##' @param dt max time interval, default is 6.
##' @param lag time intervals for linear regression to calculate diffusion coefficient, default is 2 to 5.
##' @param resolution ratio of pixel to ÂµM.
##' @param t.interval Time interval for image aquisition. Default 0.5 sec (500ms).
##' @param sort trajectories will be sorted by given parameters, "RT" for dwell time, "Dcoef" for diffusion coefficient, "Rsqare" for R squared of Mean squared Displacement (MSD) fitting.
##' 
##' @return
##' \itemize{
##' \item{PDF:} One PDF file with 120 tracks on each page.
##' }
##' @details Plot individual track/trajectory one by one, and the tracks will be layout in 15X8 grids.
##' The title of each grid indicates the sequence of the track in the original trackll.
##'              
##'
##' @examples
##'
##' # Generate trackll, and process, 
##' # e.g. mask region of interest, tracks from multiple files should not be merged.
##' folder=system.file("extdata","HSF",package="sojourner")
##' trackll=createTrackll(interact=F,folder,input=2, cores = 2)
##' trackll=maskTracks(folder,trackll)
##' trackll=mergeTracks(folder, trackll)
##' trackll=filterTrack(trackll,filter=c(7,Inf))
##' 
##' # Plot individual tracks,
##' plotIndividualMSD(trackll=trackll,dt=6,lag=c(2:5),resolution=0.107,t.interval=0.01,sort="Rsquare",plot.fit=TRUE)

##' @export plotIndividualMSD

#####################################################################################
#####################################################################################



## Function for plotting individual tracks one by one, with grid layout (120 tracks/page).
## Sorted with track length.

plotIndividualMSD<-function(trackll=trackll,dt=6,lag=c(2:5),resolution=0.107,t.interval=0.01,sort=c("RT","Rsquare","Dcoef"),plot.fit=TRUE){

#library(lattice)
#library(grid)    
    trackll<-filterTrack(trackll,filter=c(min=dt+1,max=Inf))

## Calculate MSD and Dcoef
  ## function to calculate MSD
  msd.track=function(track,dt=6,resolution=0.107,at.dt=F){
    
    if (at.dt == F){
      
      # calculate msd for track at 1~dt
      msd_track=c()
      for (i in 1:dt){
        
        # caculate msd for track at specified dt
        track.sqd=squareDisp(track,dt=i,resolution=resolution)
        # extract square.disp into a vector
        square.disp=do.call(rbind,track.sqd)$square.disp
        # remove NA and get the genuine mean
        msd_track[i]=mean(square.disp,na.rm=T)
      }
      
    }else{
      
      # caculate msd for track at specified dt
      track.sqd=squareDisp(track,dt=dt,resolution=resolution)
      # extract square.disp into a vector
      square.disp=do.call(rbind,track.sqd)$square.disp
      # remove NA and get the genuine mean
      msd_track=mean(square.disp,na.rm=T)
    }
    
    return(msd_track)
  }
  Dcoef=c()
  Dcoef.linear=c()
  MSD=c()
  regression=c()
  R.squared=c()
  trajLength=c()
  x=lag*t.interval
  dimension=2
  for (j in seq_along(trackll[[1]])){
    msd.n=msd.track(trackll[[1]][[j]], resolution=resolution,dt=dt, at.dt=F)
    MSD=append(MSD,c(0,msd.n))
    
    fit=lm(msd.n[lag]~x)
    y.fit <- predict.lm(fit, newdata = list(x = c(0:dt)*t.interval))
    regression=append(regression,y.fit)
    
    Dcoef.linear.n=coefficients(fit)[2]/(2*dimension)
    Dcoef.linear=append(Dcoef.linear,rep(Dcoef.linear.n,dt+1))
    R.squared=append(R.squared,rep(summary(fit)$r.squared,dt+1))
     
    Log.D.coef=log(Dcoef.linear.n)
    Log.D.coef=formatC(Log.D.coef,digits=2, format="f") 
    Dcoef=append(Dcoef,rep(Log.D.coef,dt+1))
    
    trajLength=append(trajLength,rep(dim(trackll[[1]][[j]])[1]*t.interval,dt+1))
  }
  time.intervals=rep(c(0:dt),length(trackll[[1]]))
  traj.No=unlist(lapply(seq_along(trackll[[1]]), function(x){rep(x,dt+1)}))
  df=data.frame(traj.No,time.intervals,MSD,regression,Dcoef.linear,Dcoef,trajLength,R.squared)

if (sort=="RT"){
  df<-df[order(df$trajLength,decreasing=TRUE),]
  new.trajSeq<-c()
  for(i in seq_along(trackll[[1]])){
    new.trajSeq=append(new.trajSeq,df$traj.No[[(dt+1)*i]])
  }

}else if (sort=="Rsquare"){
  df<-df[order(df$R.squared,decreasing=TRUE),]
  new.trajSeq<-c()
  for(i in seq_along(trackll[[1]])){
    new.trajSeq=append(new.trajSeq,df$traj.No[[(dt+1)*i]])
  }
  
}else if (sort=="Dcoef"){
  df<-df[order(df$Dcoef.linear,decreasing=TRUE),]
  new.trajSeq<-c()
  for(i in seq_along(trackll[[1]])){
    new.trajSeq=append(new.trajSeq,df$traj.No[[(dt+1)*i]])
  }
  
}
  new.trajSeq<-as.character(new.trajSeq)
  
  df$new.traj.No<-unlist(lapply(seq_along(trackll[[1]]), function(x){rep(x,dt+1)}))
  df<-transform(df,new.traj.No=factor(new.traj.No))
#df$MSD<-as.numeric(df$MSD)
#df$time.intervals<-as.numeric(df$time.intervals)

dwellTimes<-c()
Rsquares<-c()
Dcoefs<-c()
y.limits<-c()
for(i in seq_along(trackll[[1]])){
    dwellTimes=append(dwellTimes,paste("t =",df$trajLength[[(dt+1)*i]],"s",sep=" "))
    R2=as.numeric(formatC(df$R.squared[[(dt+1)*i]],digits=4, format="f"))
    Rsquares=append(Rsquares,as.expression(bquote(R^2~"="~.(R2))))
    Dcoef.n=formatC(df$Dcoef.linear[[(dt+1)*i]],digits=4, format="f")
    Dcoefs=append(Dcoefs,as.expression(bquote(D[coef]~"="~.(Dcoef.n))))
    a=10^ceiling(abs(log10(max(df$MSD[(dt+1)*i-c(dt:0)]))))
    y.max=ceiling(max(df$MSD[(dt+1)*i-c(dt:0)])*a)/a
    y.limits=append(y.limits,list(c(0,y.max)))
}

#a=10^ceiling(abs(log10(max(df$MSD))))
#y.max=ceiling(max(df$MSD)*a)/a

######################### Using the grid library to add text to each panel #####################

pdf(paste("plotIndividualMSD-",names(trackll),"-",format(Sys.time(),"%Y%m%d.%H%M%S"),".pdf",sep=""),width=11.7,height=8.3)
  MSDplot<-lattice::xyplot(df$MSD~df$time.intervals*t.interval|df$new.traj.No,df,pch=20,cex=0.8,col="black",
                            xlab="dt",ylab="MSD (um2/s)",
                            xlim=c(0,(dt+0.2)*t.interval),
                           main=paste(names(trackll), "   n=",length(trackll[[1]]),"   sorted by ",sort),
                           scales=list(x=list(at=c(0:dt)*t.interval,labels=c(0:dt)),
                                       y=list(relation='free',limits=y.limits,cex=0.5)), 
                           
                           par.strip.text = list(col = "black",cex=1),
                           strip=lattice::strip.custom(factor.levels=new.trajSeq),
                           
                           panel=function(x, y, ...) {
                             lattice::panel.xyplot(x, y, ...);
                             grid::grid.text(Rsquares[lattice::panel.number()],just = "right", grid::unit(0.98, 'npc'), 
                                             grid::unit(0.9, 'npc'),gp=grid::gpar(col="red",cex=0.6));
                             grid::grid.text(Dcoefs[lattice::panel.number()],just = "right", grid::unit(0.98, 'npc'), 
                                             grid::unit(0.8, 'npc'),gp=grid::gpar(col="darkred",cex=0.6));
                             grid::grid.text(dwellTimes[lattice::panel.number()],just = "right", grid::unit(0.98, 'npc'), 
                                             grid::unit(0.7, 'npc'),gp=grid::gpar(col="darkred",cex=0.6));},
                            layout=c(12,5),as.table=TRUE
  )
#  MSDplot + latticeExtra::layer(panel.points(df$MSD~df$time.intervals|df$traj.No,df, pch = 16, col = "orange"))
  fit.plot <- lattice::xyplot(df$regression~df$time.intervals*t.interval|df$new.traj.No,df,type="l",col="blue",
                              xlim=c(0,dt+0.2),
                              scales=list(x=list(labels=NULL),y=list(relation='free',limits=y.limits,labels=NULL)), 
                              
               layout=c(12,5),as.table=TRUE)
  par(mar = c(5,6,4,2) + 0.1)
  
  uniqueDcoef.linear=df$Dcoef.linear[(1:(length(df$traj.No)/7))*7]
  b=ceiling(abs(log10(min(uniqueDcoef.linear[which(uniqueDcoef.linear>0)]))))
  c=ceiling(abs(log10(max(uniqueDcoef.linear[which(uniqueDcoef.linear>0)]))))
  at.y <- outer(1:9, 10^((1-b):c))
  #lab.y <- ifelse(log10(at.y) %% 1 == 0, at.y, NA)
  #lab.y[1,] <- formatC(lab.y[1,],digits=10)
  #lab.y[1,] <- format(lab.y[1,],scientific=FALSE)
  lab.y<- sapply(as.numeric((1-b):c),function(i){as.expression(bquote(10^ .(i)))})
  plot(df$R.squared[(1:(length(df$traj.No)/7))*7],df$Dcoef.linear[(1:(length(df$traj.No)/7))*7],
       main=paste(names(trackll), "   n=",length(trackll[[1]])),cex.main=1.5,
       xlab=as.expression(bquote(R^2)),
       ylab=" ",cex.lab=1.5,ylim=c(10^(1-b),10^c),
       col=adjustcolor( "black", alpha.f = 0.15),pch=16,cex=1.6,log="y",yaxt="n")
  #title(ylab=as.expression(bquote(log[10]~D[coef]~" "~(um^2/s))),cex.lab=1.5,line=3.6)
  title(ylab=expression(log[10]~D[coef]~" "~(~mu*m^2/s)),cex.lab=1.5,line=3.6)
  axis(2, at=at.y[1,], labels=lab.y, las=1)
  axis(2, at=at.y, labels=NA,las=1)
  abline(v=0.8,lty=3)
  legend("bottomleft",legend=paste("n = ",length(df$R.squared[which(df$R.squared<0.8&df$Dcoef.linear>0)])/7),bty="n")
  legend("bottomright",legend=paste("n = ",length(df$R.squared[which(df$R.squared>=0.8&df$Dcoef.linear>0)])/7),bty="n")
  legend("topleft",legend=paste(length(df$R.squared[which(df$Dcoef.linear<=0)])/7, "tracks with Dcoef<0 not shown"),bty="n")
  
  plot(df$R.squared[(1:(length(df$traj.No)/7))*7],df$Dcoef.linear[(1:(length(df$traj.No)/7))*7],
       main=paste(names(trackll), "   n=",length(trackll[[1]])),cex.main=1.5,
       xlab=as.expression(bquote(R^2)),
       ylab=expression(D[coef]~" "~(~mu*m^2/s)),cex.lab=1.5,
       #ylab=parse(text = paste("D"['coef'],"*mu","m","^2","/s",sep = "")),
       col=adjustcolor( "black", alpha.f = 0.05),pch=16,cex=1.8)
  abline(v=0.8,lty=3)
  legend("bottomleft",legend=paste("n = ",length(df$R.squared[which(df$R.squared<0.8)])/7),bty="n")
  legend("bottomright",legend=paste("n = ",length(df$R.squared[which(df$R.squared>=0.8)])/7),bty="n")
  
  if(plot.fit){
    print(MSDplot + latticeExtra::as.layer(fit.plot))
  }
  

dev.off()

cat("\nThe plot has been saved as a PDF in the working directory.")
}


